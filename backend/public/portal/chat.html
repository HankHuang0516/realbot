<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="chat_title">E-Claw - Chat</title>
    <link rel="stylesheet" href="shared/style.css">
    <style>
        /* ‚îÄ‚îÄ Chat Layout ‚îÄ‚îÄ */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px);
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ Chat Header ‚îÄ‚îÄ */
        .chat-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--card-border);
            background: var(--input-bg);
        }

        .chat-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 700;
        }

        /* ‚îÄ‚îÄ Usage Badge ‚îÄ‚îÄ */
        .usage-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: var(--card);
            color: var(--text-secondary);
        }

        .usage-badge.warning { color: var(--warning); }
        .usage-badge.danger  { color: var(--danger); }
        .usage-badge.unlimited { color: var(--success); }

        /* ‚îÄ‚îÄ Filter Chips ‚îÄ‚îÄ */
        .chip-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 5px 14px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            background: var(--card);
            border: 1px solid var(--card-border);
            color: var(--text-secondary);
            transition: all 0.2s;
            white-space: nowrap;
            user-select: none;
        }

        .filter-chip:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .filter-chip.active {
            background: var(--primary);
            border-color: var(--primary);
            color: var(--text);
        }

        /* ‚îÄ‚îÄ Messages Area ‚îÄ‚îÄ */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .chat-messages::-webkit-scrollbar { width: 6px; }
        .chat-messages::-webkit-scrollbar-track { background: transparent; }
        .chat-messages::-webkit-scrollbar-thumb { background: var(--card-border); border-radius: 3px; }
        .chat-messages::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        /* ‚îÄ‚îÄ Message Bubbles ‚îÄ‚îÄ */
        .chat-msg {
            max-width: 80%;
            display: flex;
            flex-direction: column;
        }

        .chat-msg.sent {
            align-self: flex-end;
            align-items: flex-end;
        }

        .chat-msg.received {
            align-self: flex-start;
            align-items: flex-start;
        }

        .chat-source {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 3px;
        }

        .chat-bubble {
            display: inline-block;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.4;
            word-break: break-word;
        }

        .chat-msg.sent .chat-bubble {
            background: var(--primary);
            color: #fff;
            border-bottom-right-radius: 4px;
        }

        .chat-msg.received .chat-bubble {
            background: var(--input-bg);
            color: var(--text);
            border: 1px solid var(--card-border);
            border-bottom-left-radius: 4px;
        }

        .chat-meta {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 3px;
        }

        /* ‚îÄ‚îÄ Entity Label Coloring ‚îÄ‚îÄ */
        .entity-label { font-weight: 600; }
        .entity-label[data-entity="0"],
        .entity-label[data-entity="2"] { color: #FF6B6B; }
        .entity-label[data-entity="1"],
        .entity-label[data-entity="3"] { color: #FFB6C1; }

        /* ‚îÄ‚îÄ Read Receipts ‚îÄ‚îÄ */
        .chat-receipt {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
            line-height: 1.6;
        }

        .read-receipt {
            font-size: 10px;
            color: var(--text-muted);
            display: inline-block;
            margin-right: 8px;
        }

        /* ‚îÄ‚îÄ Target Bar (checkboxes) ‚îÄ‚îÄ */
        .target-bar {
            padding: 8px 16px;
            background: var(--input-bg);
            border-top: 1px solid var(--card-border);
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .target-label {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .target-check {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
        }

        .target-check input[type="checkbox"] {
            accent-color: var(--primary);
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        /* ‚îÄ‚îÄ Input Bar ‚îÄ‚îÄ */
        .chat-input-bar {
            padding: 12px 16px;
            background: var(--card);
            border-top: 1px solid var(--card-border);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .limit-warning {
            color: var(--warning);
            font-size: 12px;
            text-align: center;
            display: none;
        }

        .input-row {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            padding: 10px 16px;
            background: var(--input-bg);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            color: var(--text);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .chat-input:focus { border-color: var(--primary); }
        .chat-input::placeholder { color: var(--text-muted); }

        .btn-send {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        /* ‚îÄ‚îÄ Empty State ‚îÄ‚îÄ */
        .chat-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: var(--text-muted);
            font-size: 14px;
            gap: 8px;
            margin: auto;
        }

        .chat-empty-icon {
            font-size: 48px;
            margin-bottom: 4px;
            opacity: 0.5;
        }

        /* ‚îÄ‚îÄ Loading ‚îÄ‚îÄ */
        .chat-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            gap: 8px;
            color: var(--text-muted);
            font-size: 13px;
            margin: auto;
        }

        /* ‚îÄ‚îÄ Media in Chat ‚îÄ‚îÄ */
        .chat-photo {
            max-width: 240px;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 6px;
            cursor: pointer;
            object-fit: cover;
        }

        .chat-photo:hover { opacity: 0.9; }

        .chat-voice {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            min-width: 180px;
        }

        .voice-play-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .chat-msg.sent .voice-play-btn {
            background: rgba(255,255,255,0.25);
            color: #fff;
        }

        .chat-msg.received .voice-play-btn {
            background: var(--card-border);
            color: var(--text);
        }

        .voice-progress {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
        }

        .chat-msg.received .voice-progress {
            background: var(--card-border);
        }

        .voice-progress-fill {
            height: 100%;
            width: 0%;
            background: #fff;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .chat-msg.received .voice-progress-fill {
            background: var(--primary);
        }

        .voice-duration {
            font-size: 11px;
            opacity: 0.7;
            min-width: 32px;
            text-align: right;
        }

        /* ‚îÄ‚îÄ Photo Lightbox ‚îÄ‚îÄ */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            cursor: zoom-out;
        }

        .lightbox.active { display: flex; }

        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border-radius: 8px;
            object-fit: contain;
        }

        /* ‚îÄ‚îÄ Media Buttons in Input Bar ‚îÄ‚îÄ */
        .btn-media {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
            background: var(--input-bg);
            border: 1px solid var(--card-border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-media:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-media.recording {
            background: #ff4444;
            border-color: #ff4444;
            color: #fff;
            animation: pulse-record 1s ease-in-out infinite;
        }

        @keyframes pulse-record {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        .recording-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,68,68,0.1);
            border-radius: 8px;
            font-size: 13px;
            color: #ff4444;
        }

        .recording-indicator.active { display: flex; }

        .recording-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse-record 1s ease-in-out infinite;
        }

        .recording-actions {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .recording-actions button {
            padding: 4px 12px;
            border-radius: 12px;
            border: none;
            font-size: 12px;
            cursor: pointer;
        }

        .btn-cancel-record {
            background: var(--card-border);
            color: var(--text);
        }

        .btn-send-record {
            background: var(--primary);
            color: #fff;
        }

        /* ‚îÄ‚îÄ Photo Preview Bar ‚îÄ‚îÄ */
        .photo-preview-bar {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: var(--input-bg);
            border-top: 1px solid var(--card-border);
        }

        .photo-preview-bar.active { display: flex; }

        .photo-preview-bar img {
            width: 56px;
            height: 56px;
            border-radius: 8px;
            object-fit: cover;
            border: 1px solid var(--card-border);
        }

        .photo-preview-info {
            flex: 1;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .btn-remove-photo {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background: var(--card-border);
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .btn-remove-photo:hover {
            background: var(--danger);
            color: #fff;
        }

        /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
        @media (max-width: 640px) {
            .chat-header-row {
                flex-wrap: wrap;
                gap: 8px;
            }

            .chip-group {
                gap: 4px;
            }

            .filter-chip {
                padding: 4px 10px;
                font-size: 11px;
            }

            .target-bar {
                padding: 6px 12px;
            }

            .chat-input-bar {
                padding: 8px 12px;
            }

            .chat-msg {
                max-width: 90%;
            }
        }

        /* ‚îÄ‚îÄ Usage Limit Modal ‚îÄ‚îÄ */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-box {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .modal-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .modal-message {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-actions .btn {
            min-width: 120px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="chat-container">
            <!-- Chat Header -->
            <div class="chat-header">
                <div class="chat-header-row">
                    <span class="chat-title" data-i18n="chat_title">Chat</span>
                    <span class="usage-badge" id="usageBadge">
                        <span class="spinner" style="width:12px;height:12px;border-width:2px;"></span>
                    </span>
                </div>
                <div class="chip-group" id="filterChips">
                    <span class="filter-chip active" data-filter="all" onclick="setFilter('all')" data-i18n="chat_filter_all">All</span>
                    <!-- Entity chips injected dynamically -->
                    <span class="filter-chip" data-filter="my" onclick="setFilter('my')" data-i18n="chat_filter_my">My Messages</span>
                </div>
            </div>

            <!-- Messages Area -->
            <div class="chat-messages" id="chatMessages">
                <div class="chat-loading" id="chatLoading">
                    <div class="spinner"></div>
                    <span>Loading...</span>
                </div>
            </div>

            <!-- Target Bar (checkboxes) -->
            <div class="target-bar" id="targetBar">
                <span class="target-label" data-i18n="chat_send_to">Send to:</span>
                <label class="target-check" id="targetAll" style="display:none;">
                    <input type="checkbox" checked onchange="toggleTargetAll(this)">
                    <span data-i18n="chat_filter_all">All</span>
                </label>
            </div>

            <!-- Input Bar -->
            <div class="chat-input-bar">
                <div class="limit-warning" id="limitWarning" data-i18n="chat_limit_reached">
                    Daily message limit reached. Upgrade to Premium for unlimited messages!
                </div>
                <div class="recording-indicator" id="recordingIndicator">
                    <span class="recording-dot"></span>
                    <span id="recordingTime">0:00</span>
                    <div class="recording-actions">
                        <button class="btn-cancel-record" onclick="stopRecording(false)">Cancel</button>
                        <button class="btn-send-record" onclick="stopRecording(true)">Send</button>
                    </div>
                </div>
                <div class="photo-preview-bar" id="photoPreviewBar">
                    <img id="photoPreviewImg" src="" alt="Preview">
                    <span class="photo-preview-info" id="photoPreviewInfo">Photo attached</span>
                    <button class="btn-remove-photo" onclick="clearPendingPhoto()" title="Remove photo">&#x2715;</button>
                </div>
                <div class="input-row">
                    <button class="btn-media" id="btnPhoto" onclick="openPhotoPicker()" title="Send photo">&#x1F4F7;</button>
                    <button class="btn-media" id="btnVoice" onclick="toggleRecording()" title="Voice message">&#x1F3A4;</button>
                    <input type="text" class="chat-input" id="messageInput"
                        data-i18n="chat_input_placeholder" placeholder="Type a message..."
                        onkeydown="if(event.key==='Enter')sendMessage()">
                    <button class="btn btn-primary btn-send" id="btnSend" onclick="sendMessage()"
                        data-i18n="chat_btn_send" title="Send">&#10148;</button>
                </div>
                <input type="file" id="photoFileInput" accept="image/jpeg,image/png,image/webp" style="display:none" onchange="handlePhotoSelected(this)">
            </div>
        </div>
    </div>

    <!-- Photo Lightbox -->
    <div class="lightbox" id="lightbox" onclick="closeLightbox()">
        <img id="lightboxImg" src="" alt="">
    </div>

    <!-- Usage Limit Modal -->
    <div class="modal-overlay" id="usageLimitModal">
        <div class="modal-box">
            <div class="modal-icon">‚ö†Ô∏è</div>
            <div class="modal-title" data-i18n="chat_limit_title">Daily Limit Reached</div>
            <div class="modal-message" data-i18n="chat_limit_body">You have reached the daily limit of 15 messages. Upgrade to Premium for unlimited messaging!</div>
            <div class="modal-actions">
                <button class="btn" onclick="closeUsageLimitModal()" data-i18n="chat_limit_close">Close</button>
                <button class="btn btn-primary" onclick="window.location.href='settings.html'" data-i18n="chat_limit_upgrade">Upgrade</button>
            </div>
        </div>
    </div>

    <script src="shared/api.js"></script>
    <script src="shared/nav.js"></script>
    <script src="shared/auth.js"></script>
    <script src="../shared/telemetry.js"></script>
    <script src="../shared/i18n.js"></script>
    <script>
        // ‚îÄ‚îÄ State ‚îÄ‚îÄ
        let allMessages = [];
        let boundEntities = [];
        let boundEntityIds = new Set();
        let currentFilter = 'all';
        let refreshInterval = null;
        let isFirstLoad = true;

        const ENTITY_CHARS = {
            0: { name: 'Lobster', emoji: '\u{1F99E}' },
            1: { name: 'Pig', emoji: '\u{1F437}' },
            2: { name: 'Lobster', emoji: '\u{1F99E}' },
            3: { name: 'Pig', emoji: '\u{1F437}' }
        };

        // Entity name lookup (populated from boundEntities)
        let entityNameMap = {};

        function getEntityDisplayName(id) {
            if (entityNameMap[id]) return entityNameMap[id];
            const char = ENTITY_CHARS[id] || { name: 'Entity' };
            return char.name;
        }

        function getEntityLabel(id) {
            const char = ENTITY_CHARS[id] || { name: 'Entity', emoji: '?' };
            const name = getEntityDisplayName(id);
            return `${char.emoji} ${escapeHtml(name)} (#${id})`;
        }

        // ‚îÄ‚îÄ Init ‚îÄ‚îÄ
        window.addEventListener('DOMContentLoaded', async () => {
            renderNav('chat');
            const user = await checkAuth();
            if (!user) return;

            updateUsageBadge();
            await loadBoundEntities();
            await loadMessages();
            isFirstLoad = false;

            // Poll every 5 seconds
            refreshInterval = setInterval(async () => {
                await loadMessages();
                await refreshUsage();
            }, 5000);
        });

        // ‚îÄ‚îÄ Usage Badge ‚îÄ‚îÄ
        function updateUsageBadge() {
            const badge = document.getElementById('usageBadge');
            if (!currentUser) return;

            const isPremium = currentUser.subscriptionStatus === 'premium';
            const limit = currentUser.usageLimit;
            const used = currentUser.usageToday || 0;

            if (limit === null || limit === undefined || isPremium) {
                badge.textContent = i18n.t('chat_usage_unlimited') || 'Unlimited';
                badge.className = 'usage-badge unlimited';
            } else {
                badge.textContent = `${used}/${limit}`;
                if (used >= limit) {
                    badge.className = 'usage-badge danger';
                } else if (used >= limit * 0.8) {
                    badge.className = 'usage-badge warning';
                } else {
                    badge.className = 'usage-badge';
                }
            }

            checkLimit();
        }

        function checkLimit() {
            if (!currentUser) return;
            const isPremium = currentUser.subscriptionStatus === 'premium';
            const limit = currentUser.usageLimit;
            const used = currentUser.usageToday || 0;

            if (!isPremium && limit !== null && limit !== undefined && used >= limit) {
                document.getElementById('limitWarning').style.display = 'block';
                document.getElementById('messageInput').disabled = true;
                document.getElementById('btnSend').disabled = true;
            } else {
                document.getElementById('limitWarning').style.display = 'none';
                document.getElementById('messageInput').disabled = false;
                document.getElementById('btnSend').disabled = false;
            }
        }

        async function refreshUsage() {
            try {
                const data = await apiCall('GET', '/api/auth/me');
                if (data.user) {
                    currentUser.usageToday = data.user.usageToday;
                    currentUser.usageLimit = data.user.usageLimit;
                    currentUser.subscriptionStatus = data.user.subscriptionStatus;
                    updateUsageBadge();
                }
            } catch (e) {
                // Silent - non-critical
            }
        }

        // ‚îÄ‚îÄ Entities ‚îÄ‚îÄ
        async function loadBoundEntities() {
            try {
                const data = await apiCall('GET', `/api/entities?deviceId=${currentUser.deviceId}`);
                boundEntities = (data.entities || []).filter(e => e.isBound);
                boundEntityIds = new Set(boundEntities.map(e => e.entityId));
                entityNameMap = {};
                boundEntities.forEach(e => {
                    if (e.name) entityNameMap[e.entityId] = e.name;
                });
                renderTargetBar();
            } catch (e) {
                console.warn('Failed to load entities:', e.message);
            }
        }

        function renderTargetBar() {
            const bar = document.getElementById('targetBar');
            const allLabel = document.getElementById('targetAll');

            // Remove old dynamic checkboxes
            bar.querySelectorAll('.target-entity-check').forEach(el => el.remove());

            if (boundEntities.length === 0) {
                allLabel.style.display = 'none';
                return;
            }

            // Show "All" only if more than 1 entity
            allLabel.style.display = boundEntities.length > 1 ? '' : 'none';

            // Restore last selected targets (null = first time, default all checked)
            const saved = localStorage.getItem('chat_last_targets');
            const savedTargets = saved ? new Set(saved.split(',').map(Number)) : null;

            boundEntities.forEach(e => {
                const char = ENTITY_CHARS[e.entityId] || ENTITY_CHARS[0];
                const name = e.name || char.name;
                const isChecked = savedTargets ? savedTargets.has(e.entityId) : true;
                const label = document.createElement('label');
                label.className = 'target-check target-entity-check';
                label.innerHTML = `<input type="checkbox" data-entity="${e.entityId}" ${isChecked ? 'checked' : ''} onchange="updateTargetAll()">
                    <span>${char.emoji} ${escapeHtml(name)} (#${e.entityId})</span>`;
                bar.appendChild(label);
            });

            // Sync "All" checkbox state
            updateTargetAll();
        }

        function toggleTargetAll(checkbox) {
            const checked = checkbox.checked;
            document.querySelectorAll('.target-entity-check input[type="checkbox"]').forEach(cb => {
                cb.checked = checked;
            });
        }

        function updateTargetAll() {
            const allCb = document.querySelector('#targetAll input');
            const entityCbs = document.querySelectorAll('.target-entity-check input[type="checkbox"]');
            if (entityCbs.length === 0) return;
            const allChecked = Array.from(entityCbs).every(cb => cb.checked);
            allCb.checked = allChecked;
        }

        function getSelectedTargets() {
            const targets = [];
            document.querySelectorAll('.target-entity-check input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    targets.push(parseInt(cb.dataset.entity));
                }
            });
            // Fallback: if nothing selected but entities exist, auto-select all bound
            if (targets.length === 0 && boundEntities.length > 0) {
                boundEntities.forEach(e => targets.push(e.entityId));
            }
            return targets;
        }

        // ‚îÄ‚îÄ Messages ‚îÄ‚îÄ
        async function loadMessages() {
            try {
                const data = await apiCall('GET',
                    `/api/chat/history?deviceId=${currentUser.deviceId}&deviceSecret=${currentUser.deviceSecret}&limit=100`
                );

                if (data.success && data.messages) {
                    const prevCount = allMessages.length;
                    allMessages = data.messages;
                    renderFilterChips();
                    renderMessages(prevCount < allMessages.length);
                }
            } catch (e) {
                if (isFirstLoad) {
                    const container = document.getElementById('chatMessages');
                    container.innerHTML = '<div class="chat-empty"><div class="chat-empty-icon">&#x26A0;</div><div>Failed to load messages</div></div>';
                }
            }
        }

        // ‚îÄ‚îÄ Filtering ‚îÄ‚îÄ
        function renderFilterChips() {
            const group = document.getElementById('filterChips');

            // Remove old entity chips
            group.querySelectorAll('.filter-chip-entity').forEach(el => el.remove());

            // Determine which entities have messages
            const entityIdsWithMessages = new Set();
            allMessages.forEach(m => {
                if (m.entity_id !== null && m.entity_id !== undefined) {
                    entityIdsWithMessages.add(m.entity_id);
                }
            });

            // Insert entity chips before "My Messages" chip
            const myChip = group.querySelector('[data-filter="my"]');

            const sortedIds = Array.from(entityIdsWithMessages).sort((a, b) => a - b);
            sortedIds.forEach(id => {
                const char = ENTITY_CHARS[id] || ENTITY_CHARS[0];
                const existing = group.querySelector(`[data-filter="entity-${id}"]`);
                if (existing) {
                    // Update name in case it changed
                    existing.textContent = `${char.emoji} ${getEntityDisplayName(id)} (#${id})`;
                    return;
                }

                const chip = document.createElement('span');
                chip.className = `filter-chip filter-chip-entity${currentFilter === 'entity-' + id ? ' active' : ''}`;
                chip.dataset.filter = `entity-${id}`;
                chip.onclick = () => setFilter(`entity-${id}`);
                chip.textContent = `${char.emoji} ${getEntityDisplayName(id)} (#${id})`;
                group.insertBefore(chip, myChip);
            });
        }

        function setFilter(filter) {
            currentFilter = filter;

            // Update active state on all chips
            document.querySelectorAll('#filterChips .filter-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.filter === filter);
            });

            renderMessages(false);
        }

        function getFilteredMessages() {
            if (currentFilter === 'all') return allMessages;

            if (currentFilter === 'my') {
                return allMessages.filter(m => m.is_from_user);
            }

            // entity-N filter: also include mission_notify messages that target this entity
            const entityId = parseInt(currentFilter.split('-')[1]);
            return allMessages.filter(m => {
                if (m.entity_id === entityId) return true;
                if (m.source && m.source.startsWith('mission_notify:')) {
                    const targets = m.source.split(':')[1].split(',').map(Number);
                    return targets.includes(entityId);
                }
                return false;
            });
        }

        // ‚îÄ‚îÄ Render Messages ‚îÄ‚îÄ
        function renderMessages(hasNewMessages) {
            const container = document.getElementById('chatMessages');
            const wasAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;
            const filtered = getFilteredMessages();

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="chat-empty">
                        <div class="chat-empty-icon">&#x1F4AC;</div>
                        <div data-i18n="chat_empty">${escapeHtml(i18n.t('chat_empty'))}</div>
                        <div style="font-size:12px;" data-i18n="chat_empty_sub">${escapeHtml(i18n.t('chat_empty_sub'))}</div>
                    </div>`;
                return;
            }

            container.innerHTML = filtered.map(msg => {
                const isSent = msg.is_from_user;
                const msgClass = isSent ? 'sent' : 'received';
                const time = formatTime(msg.created_at);
                const sourceLabel = buildSourceLabel(msg);

                // Build media content
                let mediaHtml = '';
                if (msg.media_type === 'photo' && msg.media_url) {
                    mediaHtml = `<img class="chat-photo" src="${escapeHtml(msg.media_url)}" alt="Photo" onclick="openLightbox('${escapeHtml(msg.media_url)}')" loading="lazy">`;
                } else if (msg.media_type === 'voice' && msg.media_url) {
                    const durationMatch = (msg.text || '').match(/\d+/);
                    const seconds = durationMatch ? parseInt(durationMatch[0]) : 0;
                    const durStr = Math.floor(seconds / 60) + ':' + String(seconds % 60).padStart(2, '0');
                    mediaHtml = `
                        <div class="chat-voice" data-src="${escapeHtml(msg.media_url)}">
                            <button class="voice-play-btn" onclick="toggleVoice(this)">&#9654;</button>
                            <div class="voice-progress" onclick="seekVoice(event, this)"><div class="voice-progress-fill"></div></div>
                            <span class="voice-duration">${durStr}</span>
                        </div>`;
                }

                // Text content (hide placeholder text for media messages)
                const rawText = msg.text || '';
                const isPlaceholder = (rawText === '[Photo]' || rawText === '[Voice message]');
                const textHtml = (!isPlaceholder && rawText) ? escapeHtml(rawText) : '';

                // Read receipt for sent messages
                let receipt = '';
                if (isSent) {
                    if (msg.source && msg.source.startsWith('mission_notify')) {
                        const targetPart = (msg.source.split(':')[1] || '');
                        const targetIds = targetPart ? targetPart.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id)) : [];
                        const deliveredIds = new Set((msg.delivered_to || '').split(',').map(id => id.trim()).filter(Boolean));
                        const sendTo = targetIds.length > 0
                            ? 'ÁôºÈÄÅËá≥: ' + targetIds.map(id => getEntityLabel(id)).join(', ')
                            : '';
                        const statusBadges = targetIds.map(id =>
                            deliveredIds.has(String(id))
                                ? `<span class="read-receipt">${getEntityLabel(id)} \u2713 Â∑≤ËÆÄ</span>`
                                : `<span class="read-receipt" style="opacity:0.5">${getEntityLabel(id)} ...</span>`
                        ).join(' ');
                        receipt = (sendTo ? `<div style="opacity:0.7;margin-bottom:2px">${sendTo}</div>` : '')
                            + `<div>${statusBadges}</div>`;
                    } else if (msg.read_at) {
                        receipt = `<span class="read-receipt">${escapeHtml(i18n.t('chat_read') || '\u2713 Read')}</span>`;
                    } else if (msg.is_delivered) {
                        receipt = `<span class="read-receipt">\u2713 Â∑≤ËÆÄ</span>`;
                    } else {
                        receipt = `<span class="read-receipt">${escapeHtml(i18n.t('chat_sent') || '\u2713 Sent')}</span>`;
                    }
                }

                return `
                    <div class="chat-msg ${msgClass}">
                        <div class="chat-source">${sourceLabel}</div>
                        <div class="chat-bubble">${textHtml}${mediaHtml}</div>
                        <div class="chat-meta">${time}</div>
                        ${receipt ? `<div class="chat-receipt">${receipt}</div>` : ''}
                    </div>`;
            }).join('');

            // Auto-scroll
            if (isFirstLoad || hasNewMessages || wasAtBottom) {
                container.scrollTop = container.scrollHeight;
            }
        }

        /**
         * Parse entity-to-entity source pattern: "entity:0:LOBSTER->1" or "entity:0:LOBSTER->1,2,3"
         */
        function parseEntitySource(source) {
            if (!source) return null;
            const match = source.match(/^entity:(\d+):([A-Z]+)->(.+)$/);
            if (!match) return null;
            return {
                fromEntityId: parseInt(match[1]),
                character: match[2],
                targets: match[3].split(',').map(id => parseInt(id.trim()))
            };
        }

        function buildSourceLabel(msg) {
            const entityId = msg.entity_id;
            const entityHtml = `<span class="entity-label" data-entity="${entityId}">${getEntityLabel(entityId)}</span>`;

            if (msg.is_from_user) {
                // Mission notify: consolidated notification bubble
                if (msg.source && msg.source.startsWith('mission_notify')) {
                    return 'Mission Control';
                }
                // Scheduled message
                if (msg.source === 'scheduled') {
                    const schedLabel = msg.schedule_label
                        ? `${i18n.t('chat_schedule_tag')}: ${escapeHtml(msg.schedule_label)}`
                        : i18n.t('chat_schedule_tag');
                    return `üìÖ ${schedLabel} &rarr; ${entityHtml}`;
                }
                // Determine source tag
                const src = msg.source || 'client';
                let sourceTag = src;
                if (src === 'web_chat') sourceTag = 'Web';
                else if (src === 'android_chat') sourceTag = 'Android';
                else if (src === 'widget') sourceTag = 'Widget';

                return `You &rarr; ${entityHtml} &middot; ${escapeHtml(sourceTag)}`;
            }

            if (msg.is_from_bot) {
                // Check for entity-to-entity source pattern
                const parsed = parseEntitySource(msg.source);
                if (parsed) {
                    const senderHtml = `<span class="entity-label" data-entity="${parsed.fromEntityId}">${getEntityLabel(parsed.fromEntityId)}</span>`;

                    // Build ÁôºÈÄÅËá≥ with per-target Â∑≤ËÆÄ status
                    const deliveredIds = msg.delivered_to
                        ? new Set(msg.delivered_to.split(',').map(id => parseInt(id.trim())))
                        : new Set();

                    const targetLabels = parsed.targets.map(tid => {
                        const label = getEntityLabel(tid);
                        return deliveredIds.has(tid) ? `${label} Â∑≤ËÆÄ` : label;
                    });

                    return `${senderHtml} &rarr; ÁôºÈÄÅËá≥: ${targetLabels.join(', ')}`;
                }

                return entityHtml;
            }

            // Fallback for other sources
            return `${entityHtml} &middot; ${escapeHtml(msg.source || 'unknown')}`;
        }

        // ‚îÄ‚îÄ Send Message ‚îÄ‚îÄ
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            const hasPhoto = !!pendingPhotoUrl;

            // Must have text or a pending photo
            if (!text && !hasPhoto) return;

            const targets = getSelectedTargets();
            if (targets.length === 0) {
                showToast('Please select at least one entity', 'error');
                return;
            }

            // Client-side limit check
            const isPremium = currentUser.subscriptionStatus === 'premium';
            const limit = currentUser.usageLimit;
            const used = currentUser.usageToday || 0;
            if (!isPremium && limit !== null && limit !== undefined && used >= limit) {
                showToast(i18n.t('chat_limit_reached'), 'error');
                return;
            }

            const btn = document.getElementById('btnSend');
            btn.disabled = true;
            const savedContent = input.value;
            input.value = '';

            try {
                const entityId = targets.length === 1 ? targets[0] : targets;
                const payload = {
                    deviceId: currentUser.deviceId,
                    entityId: entityId,
                    text: text || (hasPhoto ? '[Photo]' : ''),
                    source: 'web_chat'
                };

                // Attach photo if pending
                if (hasPhoto) {
                    payload.mediaType = 'photo';
                    payload.mediaUrl = pendingPhotoUrl;
                }

                await apiCall('POST', '/api/client/speak', payload);

                // Save selected targets for next session
                localStorage.setItem('chat_last_targets', targets.join(','));

                // Clear pending photo
                if (hasPhoto) clearPendingPhoto();

                // Bump local usage
                if (currentUser.usageToday !== undefined) {
                    currentUser.usageToday += targets.length;
                    updateUsageBadge();
                }

                // Reload and scroll
                await loadMessages();
                const container = document.getElementById('chatMessages');
                container.scrollTop = container.scrollHeight;

            } catch (e) {
                if (e.status === 429) {
                    showUsageLimitModal();
                } else if (e.status === 403 && e.data && (e.data.error === 'GATEKEEPER_BLOCKED_MESSAGE' || e.data.error === 'GATEKEEPER_BLOCKED')) {
                    const reason = e.data.message || 'Ë®äÊÅØÂ∑≤Ë¢´ÂÆâÂÖ®Ê©üÂà∂ÊîîÊà™';
                    if (e.data.error === 'GATEKEEPER_BLOCKED') {
                        showToast('‚ö†Ô∏è ' + reason, 'error');
                    } else {
                        const strikes = e.data.strikes || 0;
                        const maxStrikes = e.data.maxStrikes || 3;
                        showToast(`‚ö†Ô∏è ${reason}Ôºà${strikes}/${maxStrikes}Ôºâ`, 'error');
                    }
                } else {
                    showToast('Send failed: ' + e.message, 'error');
                }
                input.value = savedContent;
            } finally {
                btn.disabled = false;
                input.focus();
            }
        }

        // ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // ‚îÄ‚îÄ Photo Upload (staged: upload first, then user types caption and presses send) ‚îÄ‚îÄ
        let pendingPhotoUrl = null;

        function openPhotoPicker() {
            document.getElementById('photoFileInput').click();
        }

        function clearPendingPhoto() {
            pendingPhotoUrl = null;
            document.getElementById('photoPreviewBar').classList.remove('active');
            document.getElementById('photoPreviewImg').src = '';
        }

        async function handlePhotoSelected(input) {
            const file = input.files[0];
            if (!file) return;
            input.value = ''; // Reset for next pick

            const btn = document.getElementById('btnPhoto');
            btn.disabled = true;
            btn.textContent = '‚è≥';

            try {
                // Show local preview immediately
                const localUrl = URL.createObjectURL(file);
                document.getElementById('photoPreviewImg').src = localUrl;
                document.getElementById('photoPreviewInfo').textContent = 'Uploading...';
                document.getElementById('photoPreviewBar').classList.add('active');

                // Upload to backend (Flickr)
                const formData = new FormData();
                formData.append('file', file);
                formData.append('deviceId', currentUser.deviceId);
                formData.append('deviceSecret', currentUser.deviceSecret);
                formData.append('mediaType', 'photo');

                const uploadRes = await fetch(API_BASE + '/api/chat/upload-media', {
                    method: 'POST',
                    body: formData
                });
                const uploadData = await uploadRes.json();
                if (!uploadData.success) throw new Error(uploadData.error || 'Upload failed');

                // Store the URL, show preview, let user type caption
                pendingPhotoUrl = uploadData.mediaUrl;
                document.getElementById('photoPreviewInfo').textContent = 'Photo ready ‚Äî type a caption or press send';
                document.getElementById('messageInput').focus();

            } catch (e) {
                showToast('Photo upload failed: ' + e.message, 'error');
                clearPendingPhoto();
            } finally {
                btn.disabled = false;
                btn.textContent = '\u{1F4F7}';
            }
        }

        // ‚îÄ‚îÄ Voice Recording ‚îÄ‚îÄ
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = 0;
        let recordingTimer = null;
        const MAX_RECORD_SECONDS = 180;

        function toggleRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording(true);
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.start();
                recordingStartTime = Date.now();

                // UI
                document.getElementById('btnVoice').classList.add('recording');
                document.getElementById('recordingIndicator').classList.add('active');
                updateRecordingTime();

                // Auto-stop at max duration
                recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    updateRecordingTime();
                    if (elapsed >= MAX_RECORD_SECONDS) {
                        stopRecording(true);
                    }
                }, 500);

            } catch (e) {
                showToast('Microphone access denied', 'error');
            }
        }

        function updateRecordingTime() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const m = Math.floor(elapsed / 60);
            const s = elapsed % 60;
            document.getElementById('recordingTime').textContent = `${m}:${String(s).padStart(2, '0')}`;
        }

        function stopRecording(send) {
            if (!mediaRecorder) return;

            clearInterval(recordingTimer);
            const durationSec = Math.floor((Date.now() - recordingStartTime) / 1000);

            document.getElementById('btnVoice').classList.remove('recording');
            document.getElementById('recordingIndicator').classList.remove('active');

            if (!send || durationSec < 1) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
                mediaRecorder = null;
                return;
            }

            mediaRecorder.onstop = async () => {
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                mediaRecorder = null;
                await uploadVoice(audioBlob, durationSec);
            };

            mediaRecorder.stop();
        }

        async function uploadVoice(blob, durationSec) {
            const targets = getSelectedTargets();
            if (targets.length === 0) {
                showToast('Please select at least one entity', 'error');
                return;
            }

            const btn = document.getElementById('btnVoice');
            btn.disabled = true;

            try {
                const formData = new FormData();
                formData.append('file', blob, 'voice.webm');
                formData.append('deviceId', currentUser.deviceId);
                formData.append('deviceSecret', currentUser.deviceSecret);
                formData.append('mediaType', 'voice');

                const uploadRes = await fetch(API_BASE + '/api/chat/upload-media', {
                    method: 'POST',
                    body: formData
                });
                const uploadData = await uploadRes.json();
                if (!uploadData.success) throw new Error(uploadData.error || 'Upload failed');

                const entityId = targets.length === 1 ? targets[0] : targets;
                await apiCall('POST', '/api/client/speak', {
                    deviceId: currentUser.deviceId,
                    entityId: entityId,
                    text: `[Voice ${durationSec}s]`,
                    source: 'web_chat',
                    mediaType: 'voice',
                    mediaUrl: uploadData.mediaUrl
                });

                if (currentUser.usageToday !== undefined) {
                    currentUser.usageToday += targets.length;
                    updateUsageBadge();
                }

                await loadMessages();
                const container = document.getElementById('chatMessages');
                container.scrollTop = container.scrollHeight;
            } catch (e) {
                showToast('Voice upload failed: ' + e.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        // ‚îÄ‚îÄ Voice Playback ‚îÄ‚îÄ
        let currentAudio = null;
        let currentPlayBtn = null;

        function toggleVoice(btn) {
            const voiceDiv = btn.closest('.chat-voice');
            const src = voiceDiv.dataset.src;

            // Stop current playback
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                if (currentPlayBtn) currentPlayBtn.innerHTML = '&#9654;';
                const prevFill = currentPlayBtn?.closest('.chat-voice')?.querySelector('.voice-progress-fill');
                if (prevFill) prevFill.style.width = '0%';

                if (currentPlayBtn === btn) {
                    currentPlayBtn = null;
                    return;
                }
            }

            const audio = new Audio(src);
            currentAudio = audio;
            currentPlayBtn = btn;
            btn.innerHTML = '&#9646;&#9646;';

            const progressFill = voiceDiv.querySelector('.voice-progress-fill');
            const durationLabel = voiceDiv.querySelector('.voice-duration');

            audio.addEventListener('timeupdate', () => {
                if (audio.duration) {
                    progressFill.style.width = (audio.currentTime / audio.duration * 100) + '%';
                    const rem = Math.ceil(audio.duration - audio.currentTime);
                    durationLabel.textContent = Math.floor(rem / 60) + ':' + String(rem % 60).padStart(2, '0');
                }
            });

            audio.addEventListener('ended', () => {
                btn.innerHTML = '&#9654;';
                progressFill.style.width = '0%';
                currentAudio = null;
                currentPlayBtn = null;
            });

            audio.play().catch(() => {
                showToast('Playback failed', 'error');
                btn.innerHTML = '&#9654;';
                currentAudio = null;
                currentPlayBtn = null;
            });
        }

        function seekVoice(event, progressBar) {
            if (!currentAudio) return;
            const rect = progressBar.getBoundingClientRect();
            const ratio = (event.clientX - rect.left) / rect.width;
            currentAudio.currentTime = ratio * currentAudio.duration;
        }

        // ‚îÄ‚îÄ Photo Lightbox ‚îÄ‚îÄ
        function openLightbox(url) {
            document.getElementById('lightboxImg').src = url;
            document.getElementById('lightbox').classList.add('active');
        }

        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('active');
            document.getElementById('lightboxImg').src = '';
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeLightbox();
        });

        // ‚îÄ‚îÄ Usage Limit Modal ‚îÄ‚îÄ
        function showUsageLimitModal() {
            document.getElementById('usageLimitModal').classList.add('active');
        }

        function closeUsageLimitModal() {
            document.getElementById('usageLimitModal').classList.remove('active');
        }

        // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
            if (currentAudio) { currentAudio.pause(); currentAudio = null; }
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
            }
        });
    </script>
</body>

</html>
