<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="chat_title">E-Claw - Chat</title>
    <link rel="stylesheet" href="shared/style.css">
    <style>
        /* ‚îÄ‚îÄ Chat Layout ‚îÄ‚îÄ */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px);
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ Chat Header ‚îÄ‚îÄ */
        .chat-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--card-border);
            background: var(--input-bg);
        }

        .chat-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .chat-title {
            font-size: 18px;
            font-weight: 700;
        }

        /* ‚îÄ‚îÄ Usage Badge ‚îÄ‚îÄ */
        .usage-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: var(--card);
            color: var(--text-secondary);
        }

        .usage-badge.warning { color: var(--warning); }
        .usage-badge.danger  { color: var(--danger); }
        .usage-badge.unlimited { color: var(--success); }

        /* ‚îÄ‚îÄ Filter Chips ‚îÄ‚îÄ */
        .chip-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 5px 14px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            background: var(--card);
            border: 1px solid var(--card-border);
            color: var(--text-secondary);
            transition: all 0.2s;
            white-space: nowrap;
            user-select: none;
        }

        .filter-chip:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .filter-chip.active {
            background: var(--primary);
            border-color: var(--primary);
            color: var(--text);
        }

        /* ‚îÄ‚îÄ Messages Area ‚îÄ‚îÄ */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .chat-messages::-webkit-scrollbar { width: 6px; }
        .chat-messages::-webkit-scrollbar-track { background: transparent; }
        .chat-messages::-webkit-scrollbar-thumb { background: var(--card-border); border-radius: 3px; }
        .chat-messages::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        /* ‚îÄ‚îÄ Message Bubbles ‚îÄ‚îÄ */
        .chat-msg {
            max-width: 80%;
            display: flex;
            flex-direction: column;
        }

        .chat-msg.sent {
            align-self: flex-end;
            align-items: flex-end;
        }

        .chat-msg.received {
            align-self: flex-start;
            align-items: flex-start;
        }

        .chat-source {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 3px;
        }

        .chat-bubble {
            display: inline-block;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.4;
            word-break: break-word;
            white-space: pre-wrap;
        }

        .chat-msg.sent .chat-bubble {
            background: var(--primary);
            color: #fff;
            border-bottom-right-radius: 4px;
        }

        .chat-msg.received .chat-bubble {
            background: var(--input-bg);
            color: var(--text);
            border: 1px solid var(--card-border);
            border-bottom-left-radius: 4px;
        }

        .chat-meta {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 3px;
        }

        /* ‚îÄ‚îÄ Entity Label Coloring ‚îÄ‚îÄ */
        .entity-label { font-weight: 600; }
        .entity-label[data-entity="0"],
        .entity-label[data-entity="2"] { color: #FF6B6B; }
        .entity-label[data-entity="1"],
        .entity-label[data-entity="3"] { color: #FFB6C1; }

        /* ‚îÄ‚îÄ Read Receipts ‚îÄ‚îÄ */
        .chat-receipt {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
            line-height: 1.6;
        }

        .read-receipt {
            font-size: 10px;
            color: var(--text-muted);
            display: inline-block;
            margin-right: 8px;
        }

        /* ‚îÄ‚îÄ Target Bar (checkboxes) ‚îÄ‚îÄ */
        .target-bar {
            padding: 8px 16px;
            background: var(--input-bg);
            border-top: 1px solid var(--card-border);
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .target-label {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .target-check {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
        }

        .target-check input[type="checkbox"] {
            accent-color: var(--primary);
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        /* ‚îÄ‚îÄ Input Bar ‚îÄ‚îÄ */
        .chat-input-bar {
            padding: 12px 16px;
            background: var(--card);
            border-top: 1px solid var(--card-border);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .limit-warning {
            color: var(--warning);
            font-size: 12px;
            text-align: center;
            display: none;
        }

        .input-row {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
            padding: 10px 16px;
            background: var(--input-bg);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            color: var(--text);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .chat-input:focus { border-color: var(--primary); }
        .chat-input::placeholder { color: var(--text-muted); }

        .btn-send {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        /* ‚îÄ‚îÄ Empty State ‚îÄ‚îÄ */
        .chat-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: var(--text-muted);
            font-size: 14px;
            gap: 8px;
            margin: auto;
        }

        .chat-empty-icon {
            font-size: 48px;
            margin-bottom: 4px;
            opacity: 0.5;
        }

        /* ‚îÄ‚îÄ Loading ‚îÄ‚îÄ */
        .chat-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            gap: 8px;
            color: var(--text-muted);
            font-size: 13px;
            margin: auto;
        }

        /* ‚îÄ‚îÄ Media in Chat ‚îÄ‚îÄ */
        .chat-photo {
            max-width: 240px;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 6px;
            cursor: pointer;
            object-fit: cover;
        }

        .chat-photo:hover { opacity: 0.9; }

        .chat-voice {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            min-width: 180px;
        }

        .voice-play-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .chat-msg.sent .voice-play-btn {
            background: rgba(255,255,255,0.25);
            color: #fff;
        }

        .chat-msg.received .voice-play-btn {
            background: var(--card-border);
            color: var(--text);
        }

        .voice-progress {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
        }

        .chat-msg.received .voice-progress {
            background: var(--card-border);
        }

        .voice-progress-fill {
            height: 100%;
            width: 0%;
            background: #fff;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .chat-msg.received .voice-progress-fill {
            background: var(--primary);
        }

        .voice-duration {
            font-size: 11px;
            opacity: 0.7;
            min-width: 32px;
            text-align: right;
        }

        /* ‚îÄ‚îÄ Photo Lightbox ‚îÄ‚îÄ */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            cursor: zoom-out;
        }

        .lightbox.active { display: flex; }

        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border-radius: 8px;
            object-fit: contain;
        }

        /* ‚îÄ‚îÄ Media Buttons in Input Bar ‚îÄ‚îÄ */
        .btn-media {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
            background: var(--input-bg);
            border: 1px solid var(--card-border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-media:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-media.recording {
            background: #ff4444;
            border-color: #ff4444;
            color: #fff;
            animation: pulse-record 1s ease-in-out infinite;
        }

        @keyframes pulse-record {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        .recording-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,68,68,0.1);
            border-radius: 8px;
            font-size: 13px;
            color: #ff4444;
        }

        .recording-indicator.active { display: flex; }

        .recording-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse-record 1s ease-in-out infinite;
        }

        .recording-actions {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .recording-actions button {
            padding: 4px 12px;
            border-radius: 12px;
            border: none;
            font-size: 12px;
            cursor: pointer;
        }

        .btn-cancel-record {
            background: var(--card-border);
            color: var(--text);
        }

        .btn-send-record {
            background: var(--primary);
            color: #fff;
        }

        /* ‚îÄ‚îÄ Attachment Menu ‚îÄ‚îÄ */
        .attach-menu-wrapper {
            position: relative;
            display: inline-block;
        }

        .attach-menu {
            display: none;
            position: absolute;
            bottom: 52px;
            left: 0;
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            min-width: 160px;
            z-index: 100;
            overflow: hidden;
        }

        .attach-menu.active { display: block; }

        .attach-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            font-size: 14px;
            cursor: pointer;
            color: var(--text);
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .attach-menu-item:hover {
            background: var(--input-bg);
        }

        .attach-menu-item .menu-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }

        /* ‚îÄ‚îÄ File Preview Bar (multi-file) ‚îÄ‚îÄ */
        .file-preview-bar {
            display: none;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 16px;
            background: var(--input-bg);
            border-top: 1px solid var(--card-border);
        }

        .file-preview-bar.active { display: flex; }

        .file-preview-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            font-size: 12px;
            color: var(--text-secondary);
            max-width: 220px;
        }

        .file-preview-item img {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .file-preview-item .file-icon {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background: var(--input-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            flex-shrink: 0;
        }

        .file-preview-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .file-preview-status {
            font-size: 11px;
            color: var(--text-muted);
        }

        .btn-remove-file {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: none;
            background: var(--card-border);
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            line-height: 1;
        }

        .btn-remove-file:hover {
            background: var(--danger);
            color: #fff;
        }

        /* ‚îÄ‚îÄ File attachment in chat bubble ‚îÄ‚îÄ */
        .chat-file {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            color: inherit;
        }

        .chat-msg.received .chat-file {
            background: var(--card);
            border: 1px solid var(--card-border);
        }

        .chat-file:hover { opacity: 0.85; }

        .chat-file .file-icon {
            font-size: 20px;
        }

        .chat-file .file-name {
            font-size: 13px;
            word-break: break-all;
        }

        /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
        @media (max-width: 640px) {
            .chat-header-row {
                flex-wrap: wrap;
                gap: 8px;
            }

            .chip-group {
                gap: 4px;
            }

            .filter-chip {
                padding: 4px 10px;
                font-size: 11px;
            }

            .target-bar {
                padding: 6px 12px;
            }

            .chat-input-bar {
                padding: 8px 12px;
            }

            .chat-msg {
                max-width: 90%;
            }
        }

        /* ‚îÄ‚îÄ Usage Limit Modal ‚îÄ‚îÄ */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-box {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .modal-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .modal-message {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-actions .btn {
            min-width: 120px;
        }

        /* ‚îÄ‚îÄ Link Preview Card ‚îÄ‚îÄ */
        .link-preview {
            display: flex;
            border: 1px solid var(--card-border);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 8px;
            background: var(--card);
            cursor: pointer;
            text-decoration: none;
            color: inherit;
            max-width: 320px;
        }

        .link-preview:hover {
            background: var(--input-bg);
        }

        .link-preview-img {
            width: 80px;
            min-height: 80px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .link-preview-body {
            padding: 8px 10px;
            overflow: hidden;
            flex: 1;
            min-width: 0;
        }

        .link-preview-title {
            font-size: 13px;
            font-weight: 600;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            color: var(--text);
        }

        .link-preview-desc {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .link-preview-domain {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 4px;
            opacity: 0.7;
        }

        .chat-msg.sent .link-preview {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .chat-msg.sent .link-preview:hover {
            background: rgba(255,255,255,0.18);
        }

        .chat-msg.sent .link-preview-title { color: #fff; }
        .chat-msg.sent .link-preview-desc { color: rgba(255,255,255,0.7); }
        .chat-msg.sent .link-preview-domain { color: rgba(255,255,255,0.5); }

        /* ‚îÄ‚îÄ Linkified URLs in messages ‚îÄ‚îÄ */
        .chat-bubble a.msg-link {
            color: inherit;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .chat-bubble a.msg-link:hover {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="chat-container">
            <!-- Chat Header -->
            <div class="chat-header">
                <div class="chat-header-row">
                    <span class="chat-title" data-i18n="chat_title">Chat</span>
                    <span class="usage-badge" id="usageBadge">
                        <span class="spinner" style="width:12px;height:12px;border-width:2px;"></span>
                    </span>
                </div>
                <div class="chip-group" id="filterChips">
                    <span class="filter-chip active" data-filter="all" onclick="setFilter('all')" data-i18n="chat_filter_all">All</span>
                    <!-- Entity chips injected dynamically -->
                    <span class="filter-chip" data-filter="my" onclick="setFilter('my')" data-i18n="chat_filter_my">My Messages</span>
                </div>
            </div>

            <!-- Messages Area -->
            <div class="chat-messages" id="chatMessages">
                <div class="chat-loading" id="chatLoading">
                    <div class="spinner"></div>
                    <span>Loading...</span>
                </div>
            </div>

            <!-- Target Bar (checkboxes) -->
            <div class="target-bar" id="targetBar">
                <span class="target-label" data-i18n="chat_send_to">Send to:</span>
                <label class="target-check" id="targetAll" style="display:none;">
                    <input type="checkbox" checked onchange="toggleTargetAll(this)">
                    <span data-i18n="chat_filter_all">All</span>
                </label>
            </div>

            <!-- Input Bar -->
            <div class="chat-input-bar">
                <div class="limit-warning" id="limitWarning" data-i18n="chat_limit_reached">
                    Daily message limit reached. Upgrade to Premium for unlimited messages!
                </div>
                <div class="recording-indicator" id="recordingIndicator">
                    <span class="recording-dot"></span>
                    <span id="recordingTime">0:00</span>
                    <div class="recording-actions">
                        <button class="btn-cancel-record" onclick="stopRecording(false)">Cancel</button>
                        <button class="btn-send-record" onclick="stopRecording(true)">Send</button>
                    </div>
                </div>
                <div class="file-preview-bar" id="filePreviewBar"></div>
                <div class="input-row">
                    <div class="attach-menu-wrapper">
                        <button class="btn-media" id="btnAttach" onclick="toggleAttachMenu()" title="Attach">&#x2B;</button>
                        <div class="attach-menu" id="attachMenu">
                            <button class="attach-menu-item" onclick="openPhotoPicker()">
                                <span class="menu-icon">&#x1F4F7;</span>
                                <span data-i18n="chat_attach_photo">Photo</span>
                            </button>
                            <button class="attach-menu-item" onclick="openVideoPicker()">
                                <span class="menu-icon">&#x1F3AC;</span>
                                <span data-i18n="chat_attach_video">Video</span>
                            </button>
                            <button class="attach-menu-item" onclick="openFilePicker()">
                                <span class="menu-icon">&#x1F4CE;</span>
                                <span data-i18n="chat_attach_file">File</span>
                            </button>
                        </div>
                    </div>
                    <button class="btn-media" id="btnVoice" onclick="toggleRecording()" title="Voice message">&#x1F3A4;</button>
                    <input type="text" class="chat-input" id="messageInput"
                        data-i18n="chat_input_placeholder" placeholder="Type a message..."
                        onkeydown="if(event.key==='Enter')sendMessage()">
                    <button class="btn btn-primary btn-send" id="btnSend" onclick="sendMessage()"
                        data-i18n="chat_btn_send" title="Send">&#10148;</button>
                </div>
                <input type="file" id="photoFileInput" accept="image/jpeg,image/png,image/webp" multiple style="display:none" onchange="handleFilesSelected(this, 'photo')">
                <input type="file" id="videoFileInput" accept="video/mp4,video/webm,video/quicktime" multiple style="display:none" onchange="handleFilesSelected(this, 'video')">
                <input type="file" id="fileFileInput" multiple style="display:none" onchange="handleFilesSelected(this, 'file')">
            </div>
        </div>
    </div>

    <!-- Photo Lightbox -->
    <div class="lightbox" id="lightbox" onclick="closeLightbox()">
        <img id="lightboxImg" src="" alt="">
    </div>

    <!-- Usage Limit Modal -->
    <div class="modal-overlay" id="usageLimitModal">
        <div class="modal-box">
            <div class="modal-icon">‚ö†Ô∏è</div>
            <div class="modal-title" data-i18n="chat_limit_title">Daily Limit Reached</div>
            <div class="modal-message" data-i18n="chat_limit_body">You have reached the daily limit of 15 messages. Upgrade to Premium for unlimited messaging!</div>
            <div class="modal-actions">
                <button class="btn" onclick="closeUsageLimitModal()" data-i18n="chat_limit_close">Close</button>
                <button class="btn btn-primary" onclick="window.location.href='settings.html'" data-i18n="chat_limit_upgrade">Upgrade</button>
            </div>
        </div>
    </div>

    <script src="shared/api.js"></script>
    <script src="shared/nav.js"></script>
    <script src="shared/auth.js"></script>
    <script src="../shared/telemetry.js"></script>
    <script src="../shared/i18n.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="shared/socket.js"></script>
    <script src="shared/footer.js"></script>
    <script>
        // ‚îÄ‚îÄ State ‚îÄ‚îÄ
        let allMessages = [];
        let boundEntities = [];
        let boundEntityIds = new Set();
        let currentFilter = 'all';
        let refreshInterval = null;
        let isFirstLoad = true;

        const ENTITY_CHARS = {
            0: { name: 'Lobster', emoji: '\u{1F99E}' },
            1: { name: 'Pig', emoji: '\u{1F437}' },
            2: { name: 'Lobster', emoji: '\u{1F99E}' },
            3: { name: 'Pig', emoji: '\u{1F437}' }
        };

        // Entity name lookup (populated from boundEntities)
        let entityNameMap = {};

        function getEntityDisplayName(id) {
            if (entityNameMap[id]) return entityNameMap[id];
            const char = ENTITY_CHARS[id] || { name: 'Entity' };
            return char.name;
        }

        function getEntityLabel(id) {
            const char = ENTITY_CHARS[id] || { name: 'Entity', emoji: '?' };
            const name = getEntityDisplayName(id);
            return `${char.emoji} ${escapeHtml(name)} (#${id})`;
        }

        // ‚îÄ‚îÄ Init ‚îÄ‚îÄ
        window.addEventListener('DOMContentLoaded', async () => {
            renderNav('chat');
            if (typeof renderFooter === 'function') renderFooter();
            const user = await checkAuth();
            if (!user) return;
            initPortalSocket();

            updateUsageBadge();
            await loadBoundEntities();
            await loadMessages();
            isFirstLoad = false;

            // Socket.IO real-time chat handler
            window.onSocketChatMessage = function(msg) {
                const exists = allMessages.some(m => m.id === msg.id);
                if (!exists) {
                    allMessages.push(msg);
                    renderFilterChips();
                    renderMessages(true);
                }
            };

            // Poll every 5 seconds (fallback when socket disconnected)
            refreshInterval = setInterval(async () => {
                if (!portalSocket || !portalSocket.connected) {
                    await loadMessages();
                }
                await refreshUsage();
            }, 5000);
        });

        // ‚îÄ‚îÄ Usage Badge ‚îÄ‚îÄ
        function updateUsageBadge() {
            const badge = document.getElementById('usageBadge');
            if (!currentUser) return;

            const isPremium = currentUser.subscriptionStatus === 'premium';
            const limit = currentUser.usageLimit;
            const used = currentUser.usageToday || 0;

            if (limit === null || limit === undefined || isPremium) {
                badge.textContent = i18n.t('chat_usage_unlimited') || 'Unlimited';
                badge.className = 'usage-badge unlimited';
            } else {
                badge.textContent = `${used}/${limit}`;
                if (used >= limit) {
                    badge.className = 'usage-badge danger';
                } else if (used >= limit * 0.8) {
                    badge.className = 'usage-badge warning';
                } else {
                    badge.className = 'usage-badge';
                }
            }

            checkLimit();
        }

        function checkLimit() {
            if (!currentUser) return;
            const isPremium = currentUser.subscriptionStatus === 'premium';
            const limit = currentUser.usageLimit;
            const used = currentUser.usageToday || 0;

            if (!isPremium && limit !== null && limit !== undefined && used >= limit) {
                document.getElementById('limitWarning').style.display = 'block';
                document.getElementById('messageInput').disabled = true;
                document.getElementById('btnSend').disabled = true;
            } else {
                document.getElementById('limitWarning').style.display = 'none';
                document.getElementById('messageInput').disabled = false;
                document.getElementById('btnSend').disabled = false;
            }
        }

        async function refreshUsage() {
            try {
                const data = await apiCall('GET', '/api/auth/me');
                if (data.user) {
                    currentUser.usageToday = data.user.usageToday;
                    currentUser.usageLimit = data.user.usageLimit;
                    currentUser.subscriptionStatus = data.user.subscriptionStatus;
                    updateUsageBadge();
                }
            } catch (e) {
                // Silent - non-critical
            }
        }

        // ‚îÄ‚îÄ Entities ‚îÄ‚îÄ
        async function loadBoundEntities() {
            const bar = document.getElementById('targetBar');
            if (bar && boundEntities.length === 0) {
                const hint = document.createElement('span');
                hint.className = 'target-loading-hint';
                hint.style.cssText = 'color:var(--text-muted);font-size:12px;';
                hint.textContent = 'Loading entities...';
                bar.appendChild(hint);
            }
            try {
                const data = await apiCall('GET', `/api/entities?deviceId=${currentUser.deviceId}`);
                boundEntities = (data.entities || []).filter(e => e.isBound);
                boundEntityIds = new Set(boundEntities.map(e => e.entityId));
                entityNameMap = {};
                boundEntities.forEach(e => {
                    if (e.name) entityNameMap[e.entityId] = e.name;
                });
                renderTargetBar();
            } catch (e) {
                console.warn('Failed to load entities:', e.message);
            }
        }

        function renderTargetBar() {
            const bar = document.getElementById('targetBar');
            const allLabel = document.getElementById('targetAll');

            // Remove old dynamic checkboxes and loading hints
            bar.querySelectorAll('.target-entity-check, .target-loading-hint').forEach(el => el.remove());

            if (boundEntities.length === 0) {
                allLabel.style.display = 'none';
                return;
            }

            // Show "All" only if more than 1 entity
            allLabel.style.display = boundEntities.length > 1 ? '' : 'none';

            // Restore last selected targets (null = first time, default all checked)
            const saved = localStorage.getItem('chat_last_targets');
            const savedTargets = saved ? new Set(saved.split(',').map(Number)) : null;

            boundEntities.forEach(e => {
                const char = ENTITY_CHARS[e.entityId] || ENTITY_CHARS[0];
                const name = e.name || char.name;
                const isChecked = savedTargets ? savedTargets.has(e.entityId) : true;
                const label = document.createElement('label');
                label.className = 'target-check target-entity-check';
                label.innerHTML = `<input type="checkbox" data-entity="${e.entityId}" ${isChecked ? 'checked' : ''} onchange="updateTargetAll()">
                    <span>${char.emoji} ${escapeHtml(name)} (#${e.entityId})</span>`;
                bar.appendChild(label);
            });

            // Sync "All" checkbox state
            updateTargetAll();
        }

        function toggleTargetAll(checkbox) {
            const checked = checkbox.checked;
            document.querySelectorAll('.target-entity-check input[type="checkbox"]').forEach(cb => {
                cb.checked = checked;
            });
        }

        function updateTargetAll() {
            const allCb = document.querySelector('#targetAll input');
            const entityCbs = document.querySelectorAll('.target-entity-check input[type="checkbox"]');
            if (entityCbs.length === 0) return;
            const allChecked = Array.from(entityCbs).every(cb => cb.checked);
            allCb.checked = allChecked;
        }

        function getSelectedTargets() {
            const targets = [];
            document.querySelectorAll('.target-entity-check input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    targets.push(parseInt(cb.dataset.entity));
                }
            });
            // Fallback: if nothing selected but entities exist, auto-select all bound
            if (targets.length === 0 && boundEntities.length > 0) {
                boundEntities.forEach(e => targets.push(e.entityId));
            }
            return targets;
        }

        // ‚îÄ‚îÄ Messages ‚îÄ‚îÄ
        async function loadMessages() {
            try {
                const data = await apiCall('GET',
                    `/api/chat/history?deviceId=${currentUser.deviceId}&deviceSecret=${currentUser.deviceSecret}&limit=100`
                );

                if (data.success && data.messages) {
                    const prevCount = allMessages.length;
                    allMessages = data.messages;
                    renderFilterChips();
                    renderMessages(prevCount < allMessages.length);
                }
            } catch (e) {
                if (isFirstLoad) {
                    const container = document.getElementById('chatMessages');
                    container.innerHTML = '<div class="chat-empty"><div class="chat-empty-icon">&#x26A0;</div><div>Failed to load messages</div></div>';
                }
            }
        }

        // ‚îÄ‚îÄ Filtering ‚îÄ‚îÄ
        function renderFilterChips() {
            const group = document.getElementById('filterChips');

            // Remove old entity chips
            group.querySelectorAll('.filter-chip-entity').forEach(el => el.remove());

            // Determine which entities have messages
            const entityIdsWithMessages = new Set();
            allMessages.forEach(m => {
                if (m.entity_id !== null && m.entity_id !== undefined) {
                    entityIdsWithMessages.add(m.entity_id);
                }
            });

            // Insert entity chips before "My Messages" chip
            const myChip = group.querySelector('[data-filter="my"]');

            const sortedIds = Array.from(entityIdsWithMessages).sort((a, b) => a - b);
            sortedIds.forEach(id => {
                const char = ENTITY_CHARS[id] || ENTITY_CHARS[0];
                const existing = group.querySelector(`[data-filter="entity-${id}"]`);
                if (existing) {
                    // Update name in case it changed
                    existing.textContent = `${char.emoji} ${getEntityDisplayName(id)} (#${id})`;
                    return;
                }

                const chip = document.createElement('span');
                chip.className = `filter-chip filter-chip-entity${currentFilter === 'entity-' + id ? ' active' : ''}`;
                chip.dataset.filter = `entity-${id}`;
                chip.onclick = () => setFilter(`entity-${id}`);
                chip.textContent = `${char.emoji} ${getEntityDisplayName(id)} (#${id})`;
                group.insertBefore(chip, myChip);
            });
        }

        function setFilter(filter) {
            currentFilter = filter;

            // Update active state on all chips
            document.querySelectorAll('#filterChips .filter-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.filter === filter);
            });

            renderMessages(false);
        }

        function getFilteredMessages() {
            if (currentFilter === 'all') return allMessages;

            if (currentFilter === 'my') {
                return allMessages.filter(m => m.is_from_user);
            }

            // entity-N filter: also include mission_notify messages that target this entity
            const entityId = parseInt(currentFilter.split('-')[1]);
            return allMessages.filter(m => {
                if (m.entity_id === entityId) return true;
                if (m.source && m.source.startsWith('mission_notify:')) {
                    const targets = m.source.split(':')[1].split(',').map(Number);
                    return targets.includes(entityId);
                }
                return false;
            });
        }

        // ‚îÄ‚îÄ Render Messages ‚îÄ‚îÄ
        function renderMessages(hasNewMessages) {
            const container = document.getElementById('chatMessages');
            const wasAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;
            const filtered = getFilteredMessages();

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="chat-empty">
                        <div class="chat-empty-icon">&#x1F4AC;</div>
                        <div data-i18n="chat_empty">${escapeHtml(i18n.t('chat_empty'))}</div>
                        <div style="font-size:12px;" data-i18n="chat_empty_sub">${escapeHtml(i18n.t('chat_empty_sub'))}</div>
                    </div>`;
                return;
            }

            container.innerHTML = filtered.map(msg => {
                const isSent = msg.is_from_user;
                const msgClass = isSent ? 'sent' : 'received';
                const time = formatTime(msg.created_at);
                const sourceLabel = buildSourceLabel(msg);

                // Build media content
                let mediaHtml = '';
                if (msg.media_type === 'photo' && msg.media_url) {
                    mediaHtml = `<img class="chat-photo" src="${escapeHtml(msg.media_url)}" alt="Photo" onclick="openLightbox('${escapeHtml(msg.media_url)}')" loading="lazy">`;
                } else if (msg.media_type === 'video' && msg.media_url) {
                    mediaHtml = `<video class="chat-video" src="${escapeHtml(msg.media_url)}" controls preload="metadata"
                        onclick="event.stopPropagation();"
                        style="max-width:300px; max-height:240px; border-radius:8px; display:block;"></video>`;
                } else if (msg.media_type === 'file' && msg.media_url) {
                    const fname = extractFileName(msg.text, msg.media_url);
                    mediaHtml = `<a class="chat-file" href="${escapeHtml(msg.media_url)}" target="_blank" rel="noopener">
                        <span class="file-icon">&#x1F4CE;</span>
                        <span class="file-name">${escapeHtml(fname)}</span>
                    </a>`;
                } else if (msg.media_type === 'voice' && msg.media_url) {
                    const durationMatch = (msg.text || '').match(/\d+/);
                    const seconds = durationMatch ? parseInt(durationMatch[0]) : 0;
                    const durStr = Math.floor(seconds / 60) + ':' + String(seconds % 60).padStart(2, '0');
                    mediaHtml = `
                        <div class="chat-voice" data-src="${escapeHtml(msg.media_url)}">
                            <button class="voice-play-btn" onclick="toggleVoice(this)">&#9654;</button>
                            <div class="voice-progress" onclick="seekVoice(event, this)"><div class="voice-progress-fill"></div></div>
                            <span class="voice-duration">${durStr}</span>
                        </div>`;
                }

                // Text content (hide placeholder text for media messages)
                const rawText = msg.text || '';
                const isPlaceholder = (rawText === '[Photo]' || rawText === '[Video]' || rawText === '[Voice message]' || rawText.startsWith('[File]'));
                let textHtml = '';
                let firstUrl = '';
                if (!isPlaceholder && rawText) {
                    const linkified = linkifyText(escapeHtml(rawText));
                    textHtml = linkified.html;
                    firstUrl = linkified.urls[0] || '';
                }
                const previewId = firstUrl ? `lp-${msg.id || Math.random().toString(36).slice(2)}` : '';

                // Read receipt for sent messages
                let receipt = '';
                if (isSent) {
                    if (msg.source && msg.source.startsWith('mission_notify')) {
                        const targetPart = (msg.source.split(':')[1] || '');
                        const targetIds = targetPart ? targetPart.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id)) : [];
                        const deliveredIds = new Set((msg.delivered_to || '').split(',').map(id => id.trim()).filter(Boolean));
                        const sendTo = targetIds.length > 0
                            ? 'ÁôºÈÄÅËá≥: ' + targetIds.map(id => getEntityLabel(id)).join(', ')
                            : '';
                        const statusBadges = targetIds.map(id =>
                            deliveredIds.has(String(id))
                                ? `<span class="read-receipt">${getEntityLabel(id)} \u2713 Â∑≤ËÆÄ</span>`
                                : `<span class="read-receipt" style="opacity:0.5">${getEntityLabel(id)} ...</span>`
                        ).join(' ');
                        receipt = (sendTo ? `<div style="opacity:0.7;margin-bottom:2px">${sendTo}</div>` : '')
                            + `<div>${statusBadges}</div>`;
                    } else if (msg.read_at) {
                        receipt = `<span class="read-receipt">${escapeHtml(i18n.t('chat_read') || '\u2713 Read')}</span>`;
                    } else if (msg.is_delivered) {
                        receipt = `<span class="read-receipt">\u2713 Â∑≤ËÆÄ</span>`;
                    } else {
                        receipt = `<span class="read-receipt">${escapeHtml(i18n.t('chat_sent') || '\u2713 Sent')}</span>`;
                    }
                }

                return `
                    <div class="chat-msg ${msgClass}">
                        <div class="chat-source">${sourceLabel}</div>
                        <div class="chat-bubble">${textHtml}${mediaHtml}</div>
                        ${previewId ? `<div class="link-preview-slot" id="${previewId}" data-url="${escapeHtml(firstUrl)}"></div>` : ''}
                        <div class="chat-meta">${time}</div>
                        ${receipt ? `<div class="chat-receipt">${receipt}</div>` : ''}
                    </div>`;
            }).join('');

            // Auto-scroll
            if (isFirstLoad || hasNewMessages || wasAtBottom) {
                container.scrollTop = container.scrollHeight;
            }

            // Fetch link previews for visible messages
            container.querySelectorAll('.link-preview-slot[data-url]').forEach(slot => {
                if (slot.children.length > 0) return; // already loaded
                fetchLinkPreview(slot.dataset.url, slot);
            });
        }

        /**
         * Parse entity-to-entity source pattern: "entity:0:LOBSTER->1" or "entity:0:LOBSTER->1,2,3"
         */
        function parseEntitySource(source) {
            if (!source) return null;
            const match = source.match(/^entity:(\d+):([A-Z]+)->(.+)$/);
            if (!match) return null;
            return {
                fromEntityId: parseInt(match[1]),
                character: match[2],
                targets: match[3].split(',').map(id => parseInt(id.trim()))
            };
        }

        function buildSourceLabel(msg) {
            const entityId = msg.entity_id;
            const entityHtml = `<span class="entity-label" data-entity="${entityId}">${getEntityLabel(entityId)}</span>`;

            if (msg.is_from_user) {
                // Mission notify: consolidated notification bubble
                if (msg.source && msg.source.startsWith('mission_notify')) {
                    return 'Mission Control';
                }
                // Scheduled message
                if (msg.source === 'scheduled') {
                    const schedLabel = msg.schedule_label
                        ? `${i18n.t('chat_schedule_tag')}: ${escapeHtml(msg.schedule_label)}`
                        : i18n.t('chat_schedule_tag');
                    return `üìÖ ${schedLabel} &rarr; ${entityHtml}`;
                }
                // Determine source tag
                const src = msg.source || 'client';
                let sourceTag = src;
                if (src === 'web_chat') sourceTag = 'Web';
                else if (src === 'android_chat') sourceTag = 'Android';
                else if (src === 'widget') sourceTag = 'Widget';

                return `You &rarr; ${entityHtml} &middot; ${escapeHtml(sourceTag)}`;
            }

            if (msg.is_from_bot) {
                // Check for entity-to-entity source pattern
                const parsed = parseEntitySource(msg.source);
                if (parsed) {
                    const senderHtml = `<span class="entity-label" data-entity="${parsed.fromEntityId}">${getEntityLabel(parsed.fromEntityId)}</span>`;

                    // Build ÁôºÈÄÅËá≥ with per-target Â∑≤ËÆÄ status
                    const deliveredIds = msg.delivered_to
                        ? new Set(msg.delivered_to.split(',').map(id => parseInt(id.trim())))
                        : new Set();

                    const targetLabels = parsed.targets.map(tid => {
                        const label = getEntityLabel(tid);
                        return deliveredIds.has(tid) ? `${label} Â∑≤ËÆÄ` : label;
                    });

                    return `${senderHtml} &rarr; ÁôºÈÄÅËá≥: ${targetLabels.join(', ')}`;
                }

                return entityHtml;
            }

            // Fallback for other sources
            return `${entityHtml} &middot; ${escapeHtml(msg.source || 'unknown')}`;
        }

        // ‚îÄ‚îÄ Send Message ‚îÄ‚îÄ
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            const readyFiles = pendingFiles.filter(f => f.status === 'ready');
            const hasFiles = readyFiles.length > 0;

            // Must have text or pending files
            if (!text && !hasFiles) return;

            // Check if any files still uploading
            if (pendingFiles.some(f => f.status === 'uploading')) {
                showToast(i18n.t('chat_wait_upload') || 'Please wait for uploads to finish', 'error');
                return;
            }

            const targets = getSelectedTargets();
            if (targets.length === 0) {
                showToast('Please select at least one entity', 'error');
                return;
            }

            // Client-side limit check
            const isPremium = currentUser.subscriptionStatus === 'premium';
            const limit = currentUser.usageLimit;
            const used = currentUser.usageToday || 0;
            if (!isPremium && limit !== null && limit !== undefined && used >= limit) {
                showToast(i18n.t('chat_limit_reached'), 'error');
                return;
            }

            const btn = document.getElementById('btnSend');
            btn.disabled = true;
            const savedContent = input.value;
            input.value = '';

            try {
                const entityId = targets.length === 1 ? targets[0] : targets;

                if (hasFiles) {
                    // Send one message per file; first file carries caption text
                    for (let i = 0; i < readyFiles.length; i++) {
                        const f = readyFiles[i];
                        const msgText = (i === 0 && text) ? text : (f.type === 'photo' ? '[Photo]' : f.type === 'video' ? '[Video]' : `[File] ${f.fileName}`);
                        await apiCall('POST', '/api/client/speak', {
                            deviceId: currentUser.deviceId,
                            entityId: entityId,
                            text: msgText,
                            source: 'web_chat',
                            mediaType: f.type,
                            mediaUrl: f.mediaUrl
                        });
                    }
                    // If user typed text but there's no file to carry it as first, shouldn't happen (handled above)
                } else {
                    // Text-only message
                    await apiCall('POST', '/api/client/speak', {
                        deviceId: currentUser.deviceId,
                        entityId: entityId,
                        text: text,
                        source: 'web_chat'
                    });
                }

                // Save selected targets for next session
                localStorage.setItem('chat_last_targets', targets.join(','));

                // Clear pending files
                if (hasFiles) clearAllPendingFiles();

                // Bump local usage
                if (currentUser.usageToday !== undefined) {
                    const msgCount = hasFiles ? readyFiles.length : 1;
                    currentUser.usageToday += msgCount * targets.length;
                    updateUsageBadge();
                }

                // Reload and scroll
                await loadMessages();
                const container = document.getElementById('chatMessages');
                container.scrollTop = container.scrollHeight;

            } catch (e) {
                if (e.status === 429) {
                    showUsageLimitModal();
                } else if (e.status === 403 && e.data && (e.data.error === 'GATEKEEPER_BLOCKED_MESSAGE' || e.data.error === 'GATEKEEPER_BLOCKED')) {
                    const reason = e.data.message || 'Ë®äÊÅØÂ∑≤Ë¢´ÂÆâÂÖ®Ê©üÂà∂ÊîîÊà™';
                    if (e.data.error === 'GATEKEEPER_BLOCKED') {
                        showToast('‚ö†Ô∏è ' + reason, 'error');
                    } else {
                        const strikes = e.data.strikes || 0;
                        const maxStrikes = e.data.maxStrikes || 3;
                        showToast(`‚ö†Ô∏è ${reason}Ôºà${strikes}/${maxStrikes}Ôºâ`, 'error');
                    }
                } else {
                    showToast('Send failed: ' + e.message, 'error');
                }
                input.value = savedContent;
            } finally {
                btn.disabled = false;
                input.focus();
            }
        }

        // ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function extractFileName(text, url) {
            // Try to extract from text like "[File] filename.pdf"
            if (text && text.startsWith('[File] ')) return text.slice(7);
            // Fallback: extract from URL
            try {
                const parts = url.split('/');
                return decodeURIComponent(parts[parts.length - 1]) || 'File';
            } catch (e) { return 'File'; }
        }

        // URL regex for detecting links in message text
        const urlRegex = /(https?:\/\/[^\s<>"']+)/gi;

        function linkifyText(escapedHtml) {
            if (!escapedHtml) return { html: '', urls: [] };
            const urls = [];
            const html = escapedHtml.replace(urlRegex, (match) => {
                urls.push(match);
                return `<a class="msg-link" href="${match}" target="_blank" rel="noopener">${match}</a>`;
            });
            return { html, urls };
        }

        // Link preview cache (client-side)
        const linkPreviewClientCache = {};

        async function fetchLinkPreview(url, container) {
            if (linkPreviewClientCache[url] === 'none') return;
            if (linkPreviewClientCache[url]) {
                container.innerHTML = linkPreviewClientCache[url];
                return;
            }
            try {
                const res = await fetch(`/api/link-preview?url=${encodeURIComponent(url)}`);
                if (!res.ok) { linkPreviewClientCache[url] = 'none'; return; }
                const data = await res.json();
                if (!data.title && !data.description) { linkPreviewClientCache[url] = 'none'; return; }

                let domain = '';
                try { domain = new URL(url).hostname; } catch {}

                const imgHtml = data.image
                    ? `<img class="link-preview-img" src="${escapeHtml(data.image)}" alt="" onerror="this.style.display='none'">`
                    : '';
                const cardHtml = `<a class="link-preview" href="${escapeHtml(url)}" target="_blank" rel="noopener">
                    ${imgHtml}
                    <div class="link-preview-body">
                        <div class="link-preview-title">${escapeHtml(data.title)}</div>
                        ${data.description ? `<div class="link-preview-desc">${escapeHtml(data.description)}</div>` : ''}
                        <div class="link-preview-domain">${escapeHtml(domain)}</div>
                    </div>
                </a>`;

                linkPreviewClientCache[url] = cardHtml;
                container.innerHTML = cardHtml;
            } catch {
                linkPreviewClientCache[url] = 'none';
            }
        }

        // ‚îÄ‚îÄ Attachment Menu ‚îÄ‚îÄ
        function toggleAttachMenu() {
            const menu = document.getElementById('attachMenu');
            menu.classList.toggle('active');
        }

        // Close menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            const wrapper = document.querySelector('.attach-menu-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                document.getElementById('attachMenu').classList.remove('active');
            }
        });

        // ‚îÄ‚îÄ Multi-File Upload ‚îÄ‚îÄ
        const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
        let pendingFiles = []; // { id, file, type ('photo'|'file'), status ('uploading'|'ready'|'error'), mediaUrl, localUrl, fileName }

        function openPhotoPicker() {
            document.getElementById('attachMenu').classList.remove('active');
            document.getElementById('photoFileInput').click();
        }

        function openVideoPicker() {
            document.getElementById('attachMenu').classList.remove('active');
            document.getElementById('videoFileInput').click();
        }

        function openFilePicker() {
            document.getElementById('attachMenu').classList.remove('active');
            document.getElementById('fileFileInput').click();
        }

        function handleFilesSelected(input, type) {
            const files = Array.from(input.files);
            input.value = '';
            if (!files.length) return;

            for (const file of files) {
                if (file.size > MAX_FILE_SIZE) {
                    showToast((i18n.t('chat_file_too_large') || 'File too large (max 100MB)') + ': ' + file.name, 'error');
                    continue;
                }
                const id = Date.now() + '_' + Math.random().toString(36).substr(2, 6);
                const isImage = file.type.startsWith('image/');
                const isVideo = file.type.startsWith('video/');
                const localUrl = isImage ? URL.createObjectURL(file) : null;
                const localVideoUrl = isVideo ? URL.createObjectURL(file) : null;
                const entryType = isImage ? 'photo' : isVideo ? 'video' : type;
                const entry = { id, file, type: entryType, status: 'uploading', mediaUrl: null, localUrl, localVideoUrl, fileName: file.name };
                pendingFiles.push(entry);
                renderFilePreviewBar();
                uploadPendingFile(entry);
            }
        }

        async function uploadPendingFile(entry) {
            try {
                const formData = new FormData();
                formData.append('file', entry.file);
                formData.append('deviceId', currentUser.deviceId);
                formData.append('deviceSecret', currentUser.deviceSecret);
                formData.append('mediaType', entry.type);

                const uploadRes = await fetch(API_BASE + '/api/chat/upload-media', {
                    method: 'POST',
                    body: formData
                });
                const uploadData = await uploadRes.json();
                if (!uploadData.success) throw new Error(uploadData.error || 'Upload failed');

                entry.status = 'ready';
                entry.mediaUrl = uploadData.mediaUrl;
            } catch (e) {
                entry.status = 'error';
                showToast((i18n.t('chat_upload_failed') || 'Upload failed') + ': ' + e.message, 'error');
            }
            renderFilePreviewBar();
        }

        function removePendingFile(id) {
            const idx = pendingFiles.findIndex(f => f.id === id);
            if (idx >= 0) {
                if (pendingFiles[idx].localUrl) URL.revokeObjectURL(pendingFiles[idx].localUrl);
                if (pendingFiles[idx].localVideoUrl) URL.revokeObjectURL(pendingFiles[idx].localVideoUrl);
                pendingFiles.splice(idx, 1);
            }
            renderFilePreviewBar();
        }

        function clearAllPendingFiles() {
            pendingFiles.forEach(f => { if (f.localUrl) URL.revokeObjectURL(f.localUrl); if (f.localVideoUrl) URL.revokeObjectURL(f.localVideoUrl); });
            pendingFiles = [];
            renderFilePreviewBar();
        }

        function renderFilePreviewBar() {
            const bar = document.getElementById('filePreviewBar');
            if (pendingFiles.length === 0) {
                bar.classList.remove('active');
                bar.innerHTML = '';
                return;
            }
            bar.classList.add('active');
            bar.innerHTML = pendingFiles.map(f => {
                const isImage = f.type === 'photo' && f.localUrl;
                const isVideo = f.type === 'video' && f.localVideoUrl;
                const thumb = isImage
                    ? `<img src="${f.localUrl}" alt="Preview">`
                    : isVideo
                    ? `<video src="${f.localVideoUrl}" style="width:48px;height:48px;object-fit:cover;border-radius:6px;" muted></video>`
                    : `<div class="file-icon">&#x1F4CE;</div>`;
                const statusText = f.status === 'uploading' ? (i18n.t('chat_uploading') || 'Uploading...')
                    : f.status === 'error' ? (i18n.t('chat_upload_error') || 'Error')
                    : '';
                const nameDisplay = escapeHtml(f.fileName.length > 20 ? f.fileName.slice(0, 17) + '...' : f.fileName);
                return `<div class="file-preview-item">
                    ${thumb}
                    <div style="flex:1;min-width:0;">
                        <div class="file-preview-name">${nameDisplay}</div>
                        ${statusText ? `<div class="file-preview-status">${statusText}</div>` : ''}
                    </div>
                    <button class="btn-remove-file" onclick="removePendingFile('${f.id}')" title="Remove">&#x2715;</button>
                </div>`;
            }).join('');
        }

        // ‚îÄ‚îÄ Voice Recording ‚îÄ‚îÄ
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = 0;
        let recordingTimer = null;
        const MAX_RECORD_SECONDS = 180;

        function toggleRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording(true);
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.start();
                recordingStartTime = Date.now();

                // UI
                document.getElementById('btnVoice').classList.add('recording');
                document.getElementById('recordingIndicator').classList.add('active');
                updateRecordingTime();

                // Auto-stop at max duration
                recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    updateRecordingTime();
                    if (elapsed >= MAX_RECORD_SECONDS) {
                        stopRecording(true);
                    }
                }, 500);

            } catch (e) {
                showToast('Microphone access denied', 'error');
            }
        }

        function updateRecordingTime() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const m = Math.floor(elapsed / 60);
            const s = elapsed % 60;
            document.getElementById('recordingTime').textContent = `${m}:${String(s).padStart(2, '0')}`;
        }

        function stopRecording(send) {
            if (!mediaRecorder) return;

            clearInterval(recordingTimer);
            const durationSec = Math.floor((Date.now() - recordingStartTime) / 1000);

            document.getElementById('btnVoice').classList.remove('recording');
            document.getElementById('recordingIndicator').classList.remove('active');

            if (!send || durationSec < 1) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
                mediaRecorder = null;
                return;
            }

            mediaRecorder.onstop = async () => {
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                mediaRecorder = null;
                await uploadVoice(audioBlob, durationSec);
            };

            mediaRecorder.stop();
        }

        async function uploadVoice(blob, durationSec) {
            const targets = getSelectedTargets();
            if (targets.length === 0) {
                showToast('Please select at least one entity', 'error');
                return;
            }

            const btn = document.getElementById('btnVoice');
            btn.disabled = true;

            try {
                const formData = new FormData();
                formData.append('file', blob, 'voice.webm');
                formData.append('deviceId', currentUser.deviceId);
                formData.append('deviceSecret', currentUser.deviceSecret);
                formData.append('mediaType', 'voice');

                const uploadRes = await fetch(API_BASE + '/api/chat/upload-media', {
                    method: 'POST',
                    body: formData
                });
                const uploadData = await uploadRes.json();
                if (!uploadData.success) throw new Error(uploadData.error || 'Upload failed');

                const entityId = targets.length === 1 ? targets[0] : targets;
                await apiCall('POST', '/api/client/speak', {
                    deviceId: currentUser.deviceId,
                    entityId: entityId,
                    text: `[Voice ${durationSec}s]`,
                    source: 'web_chat',
                    mediaType: 'voice',
                    mediaUrl: uploadData.mediaUrl
                });

                if (currentUser.usageToday !== undefined) {
                    currentUser.usageToday += targets.length;
                    updateUsageBadge();
                }

                await loadMessages();
                const container = document.getElementById('chatMessages');
                container.scrollTop = container.scrollHeight;
            } catch (e) {
                showToast('Voice upload failed: ' + e.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        // ‚îÄ‚îÄ Voice Playback ‚îÄ‚îÄ
        let currentAudio = null;
        let currentPlayBtn = null;

        function toggleVoice(btn) {
            const voiceDiv = btn.closest('.chat-voice');
            const src = voiceDiv.dataset.src;

            // Stop current playback
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                if (currentPlayBtn) currentPlayBtn.innerHTML = '&#9654;';
                const prevFill = currentPlayBtn?.closest('.chat-voice')?.querySelector('.voice-progress-fill');
                if (prevFill) prevFill.style.width = '0%';

                if (currentPlayBtn === btn) {
                    currentPlayBtn = null;
                    return;
                }
            }

            const audio = new Audio(src);
            currentAudio = audio;
            currentPlayBtn = btn;
            btn.innerHTML = '&#9646;&#9646;';

            const progressFill = voiceDiv.querySelector('.voice-progress-fill');
            const durationLabel = voiceDiv.querySelector('.voice-duration');

            audio.addEventListener('timeupdate', () => {
                if (audio.duration) {
                    progressFill.style.width = (audio.currentTime / audio.duration * 100) + '%';
                    const rem = Math.ceil(audio.duration - audio.currentTime);
                    durationLabel.textContent = Math.floor(rem / 60) + ':' + String(rem % 60).padStart(2, '0');
                }
            });

            audio.addEventListener('ended', () => {
                btn.innerHTML = '&#9654;';
                progressFill.style.width = '0%';
                currentAudio = null;
                currentPlayBtn = null;
            });

            audio.play().catch(() => {
                showToast('Playback failed', 'error');
                btn.innerHTML = '&#9654;';
                currentAudio = null;
                currentPlayBtn = null;
            });
        }

        function seekVoice(event, progressBar) {
            if (!currentAudio) return;
            const rect = progressBar.getBoundingClientRect();
            const ratio = (event.clientX - rect.left) / rect.width;
            currentAudio.currentTime = ratio * currentAudio.duration;
        }

        // ‚îÄ‚îÄ Photo Lightbox ‚îÄ‚îÄ
        function openLightbox(url) {
            document.getElementById('lightboxImg').src = url;
            document.getElementById('lightbox').classList.add('active');
        }

        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('active');
            document.getElementById('lightboxImg').src = '';
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeLightbox();
        });

        // ‚îÄ‚îÄ Usage Limit Modal ‚îÄ‚îÄ
        function showUsageLimitModal() {
            document.getElementById('usageLimitModal').classList.add('active');
        }

        function closeUsageLimitModal() {
            document.getElementById('usageLimitModal').classList.remove('active');
        }

        // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ
        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
            if (currentAudio) { currentAudio.pause(); currentAudio = null; }
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
            }
        });
    </script>
</body>

</html>
